---
title: 从零学习Rust 01
route: Study-Rust-01
description: Study Rust
time: 2023/06/27 10:23:00
tags:
  - Rust
---


# 从零学习Rust 01 所有权

[视频地址](https://www.bilibili.com/video/BV1hp4y1k7SV?p=16&spm_id_from=pageDriver&vd_source=888e5b3129deb84d49dd800b76a6e557)

## Rust的所有权机制

`所有权` 是Rust的核心特性.

所有程序在运行时都必须管理他们使用计算机内存的方式.

* 有些语言有垃圾收集机制, 在程序运行时, 它们会不断地寻找不再使用的内存.
* 在其他语言中, 我们必须显式地分配释放内存(`C`, `C++`).

`Rust`的方式是:

* 内存是通过一个`所有权系统`来管理, 其中包含一组编译器在`编译时`检查的规则(没有运行时开销).
* 程序运行时, `所有权特性`不会使运行速度减慢(检查在编译时发生).

## Stack(栈内存) 和 Heap(堆内存)

### 一些概念

栈按值的接收顺序来存储, 相反的顺序移除(后进先出, `LIFO`).

所有存储在栈上的数据必须拥有**已知**的**固定**大小.

* `编译时大小未知`的数据或者`运行时大小可能发生变化`的数据必须存放在堆上.

堆内存组织性差一些.

* 把数据放进堆时, 会请求一定数量的空间.
* 操作系统在堆中找到一块足够大的空间, 把它标记为`在用`, 并且返回一个`指针`, 也就是这个空间的地址.
* 这个过程叫做`分配`.

因为指针是已知固定大小的, 可以把指针存放到栈上.

* 但如果想要实际数据, 那么就必须使用指针来定位.

把数据压到栈上要比在堆上分配快得多:

* 因为操作系统不需要寻找用来存储新数据的空间, 放在栈顶就好了.

在堆上分配空间需要做更多的工作:

* 需要找到一个足够大的空间来存数据, 然后做好记录方便下次分配.

访问堆中的数据要比访问栈中的要慢, 因为需要`指针`.

* 由于缓存的缘故, 如果指令在内存中跳转的次数越少, 那么速度就越快.

如果存放数据的距离近, 那么处理器的处理速度就会快一些(放在栈上), 相反, 就会慢一些.

* 在堆上分配大量空间也是需要时间的.

### 函数调用

当代码调用函数时, 值被传入到函数(包括指针). 函数本地的变量被压到栈上. 当函数结束后, 这些值会在栈上弹出.

### 所有权解决的问题

跟踪代码的哪些部分正在使用堆的哪些数据.

最小化堆上的重复数据量.

清理堆上未使用的数据以避免空间不足.

## 所有权规则

每个值都有一个变量, 这个变量是该值的所有者.

每个值同时只能有一个所有者.

当所有者超出作用域(`scope`)时, 该值将被删除.

### 作用域

和`JS`中有些类似.

```rust
fn main() {
    // s 不可用
    let s = "hello"; // 可用
    // 这后面可以对s后进行操作
}
// 作用域结束, s 不可用
```

## 举个例子 String类型

字符串字面值, 在编译时就知道它的内容了, 其文本内容直接被硬编码到最终的可执行文件里.

* 速度快, 是因为其不可变.

```rust
let s = "123";
```

`String`类型, 为了支持其可变性, 需要在`Heap`上分配内存来保存编译时未知的文本内容.

* 操作系统必须在运行时来请求内存(通过调用`String::from`实现).
* 用完`String`后, 需要使用某种方式将内存返回给操作系统.
* 拥有`GC`的语言中, `GC`会跟踪并且清理内存.
* 没有`GC`, 就需要我们手动调用代码返回.(忘做了会浪费内存, 提前做了变量会非法)

`Rust`的方式是: 对于某个值, 当**拥有它的变量走出作用范围时**, 内存会立即自动的交还给操作系统(释放).

`drop函数`
